本题是经典的最长公共子序列（LCS）问题，也是我第一次接触这类题目。

一开始把子序列与子串搞混了，还觉得“困难题就这？”，然后就被题目狠狠的教育了。看了几个小时的题解，终于理解了，所以写下题解当作笔记。

解决本题的核心思路就是将两个字符串`str1`与`str2`重复的子序列，也就是公共子序列计入一次，再把`str1`与`str2`中公共子序列以外的部分各自计入一次。很显然，公共子序列越长，总共计入的字符就越少，所以本题本质上是求`str1`与`str2`的最长公共子序列。

此类题目虽然是一种典型的动态规划题目，但只靠dp是不够的，因为在记录状态时，直接记录序列本身是不现实的，我们只能记录序列的长度，而如何把长度转变成序列本身才是此类题目最大的难点。

如何根据长度还原序列放在之后再说，因为弄明白状态转移方程后才能更好的理解。我们先解决动态规划这一部分。

# 动态规划

在学习过程中，我看了很多题解，其中主要有两种思路，一种是使用`dp[i][j]`记录字符串`str1`的前i个字符和字符串`str2`的前j个字符的最长公共子序列,这种思路是将先将问题转化为了最典型的LCS问题。而另一种思路是直接使用`dp[i][j]`记录字符串`str1`的前i个字符和字符串`str2`的前j个字符的最短公共超序列。两种思路虽然一个“最长”一个“最短”，一个“子序列”一个“超序列”，但其实本质思想都与LCS问题相同。

- 思路一

首先详解一下第一种思路，使用`dp[i][j]`记录字符串`str1`的前i个字符和字符串`str2`的前j个字符的最长公共子序列。使用i、j作为描述状态的两个维度，那么状态的转移无非只有两种情况，`str1[i]`与`str2[j]`相等或不相等。如果相等，那么这个字符也要被加入公共子序列，所以最长公共子序列的长度要在`dp[i-1][j-1]`上加1；如果不相等，那么该字符不能加入公共子序列，最长的子序列应该等于两个相邻状态，也就是`dp[i-1][j]`和`dp[i][j-1]`中更大的一个。这里可能会有人疑问，为什么相等时要从`dp[i-1][j-1]`这个不相邻的状态转移？因为必须确保`str1[i]`或`str2[j]`并没有与其他相等的字符加入过公共子序列，如果是相邻的状态，那么两个字符会有其中一个在该状态中，此时该字符有可能已经在公共子序列内。

所以状态转移方程为：
$dp[i][j]=dp[i-1][j-1]+1,0<i<m,0<j<n$
$dp[i][j]=max(dp[i-1][j],dp[i][j-1]),0<i<m,0<j<n$

然后就是确定边界条件，因为dp数组记录的是最长公共子序列，所以`dp
[0][j]`与`dp[i][0]`都是0。

- 思路二

该思路是直接使用`dp[i][j]`记录字符串`str1`的前i个字符和字符串`str2`的前j个字符的最短公共超序列。

如果说最长公共子序列是求交集，最短公共超序列就是求并集。所以边界条件就可以确定了，`dp[0][j]=j`,`dp[i][0]=i`，在其中一者为空字符串时，另一字符串本身就是两个字符串的最短公共超序列。

状态转移方程与思路一其实大同小异，状态的转移也是只有两种情况，`str1[i]`与`str2[j]`相等或不相等。在`str1[i]`与`str2[j]`相等时，转移方程与思路一相同，将其加入公共子序列，最长公共子序列的长度在`dp[i-1][j-1]`基础上加1；如果不相等，要在两个相邻状态中更小的状态上加1。取更小状态很容易理解，因为是“最短”，但是该思路在不相等时也要加1，因为是求的超序列，即使不相等，超序列也要包括这个字符，所以依然加1。

状态转移方程为：

$dp[i][j]=dp[i-1][j-1]+1,0<i<m,0<j<n$
$dp[i][j]=min(dp[i-1][j],dp[i][j-1])+1,0<i<m,0<j<n$

# 双指针

看到标题应该已经明白如何根据长度还原序列了。接下来的步骤就是使用双指针还原最短公共超序列。

为了解决动态规划只能记录长度无法记录序列本身这一问题，我们要根据状态转移方程与状态之间的关系来逆推状态转移的过程。

之前提到的两种思路在接下来的思路基本一致，因为dp数组本身并不是为了解决问题，而是辅助逆推状态转移，换句话说，只要dp的思路是正确的，dp数组中存储了什么值其实并不重要，而在本题中，求最长公共子序列与最短公共超序列本质是一样的。

为了表示状态的两个维度i、j，我们使用双指针i和j分别指向字符串`str1`和`str2`的末尾，之所以指向末尾，是因为之前状态转移是从前向后，此时为了更好地逆推状态转移，我们采取相反的方向。

如果`str1[i]`与`str2[j]`相等，则`dp[i][j]`由`dp[i-1][j-1]`转移而来，将`str1[i]`加入最终需要返回的序列中，然后i、j都向前移动一位。

如果`str1[i]`与`str2[j]`不相等，则需要判断`dp[i][j]`到底是由哪个状态转移而来。判断方式只需要逆推状态转移方程，如果是思路一，就将`dp[i][j]`与`dp[i-1][j]`、`dp[i][j-1]`作比较，与谁相等便是由谁转移而来，思路二同理，将`dp[i][j]`与`dp[i-1][j]+1`、`dp[i][j-1]+1`作比较。如果`dp[i][j]`由`dp[i-1][j]`转移而来，就将`str1[i]`加入序列，然后i向前移；如果`dp[i][j]`由`dp[i][j-1]`转移而来，就将`str2[j]`加入序列，然后j向前移。

如果到达边界条件，也就是i或j先到0，就将未到0的指针所在的字符串剩下的字符全部加入序列。

因为我们是逆推，所以别忘了将字符串反转。

最后是代码（以思路一为例）：

* 

```
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        int m = str1.size(), n = str2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1,0));
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (str1[i - 1] == str2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        int i = m, j = n;
        string ans;
        while (i>0||j>0) {
            if (i == 0){
                ans += str2[--j];
            }
            else if (j == 0){
                ans += str1[--i];
            }
            else {
                if (dp[i][j] == dp[i - 1][j]){
                    ans += str1[--i];       
                }
                else if (dp[i][j] == dp[i][j - 1]){
                    ans += str2[--j];
                }
                else{
                    ans += str1[--i];
                    j--;
                }
            }
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

